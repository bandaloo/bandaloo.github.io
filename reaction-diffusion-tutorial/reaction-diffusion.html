<!DOCTYPE html>
<html lang="en">
  <head>
    <style>
      body {
        margin: 0;
        background: black;
      }
      canvas {
        width: 100%;
        height: 100%;
        position: relative;
      }
    </style>
  </head>

  <body>
    <canvas></canvas>
  </body>
  <!-- --- add script tags to hold all the shaders we will use --- -->
  <script id="vshader" type="whatever">
    precision mediump float;
    attribute vec2 a_position;
    void main() {
      gl_Position = vec4( a_position, 0, 1.0);
    }
  </script>

  <script id="fshader_draw" type="whatever">
    precision mediump float;
    uniform sampler2D state;
    uniform vec2 scale;

    void main() {
      vec4 color = texture2D(state, gl_FragCoord.xy / scale);
      gl_FragColor = vec4( 1.-color.x, 1.-color.x, 1.-color.x, 1. );
    }
  </script>

  <script id="fshader_render" type="whatever">
    precision mediump float;
    uniform sampler2D state;
    uniform vec2 scale;
    //float f=.0545, k=.062, dA = 1., dB = 0.; // coral preset
    float f = .0457, k = .0635, dA = 1., dB = .5;

    vec2 get(int x, int y) {
      return texture2D( state, ( gl_FragCoord.xy + vec2(x, y) ) / scale ).rg;
    }

    vec2 run() {
      vec2 state = get( 0, 0 );
      float a = state.r;
      float b = state.g;
      float sumA = a * -1.;
      float sumB = b * -1.;

      sumA += get(-1,0).r * .2;
      sumA += get(-1,-1).r * .05;
      sumA += get(0,-1).r * .2;
      sumA += get(1,-1).r * .05;
      sumA += get(1,0).r * .2;
      sumA += get(1,1).r * .05;
      sumA += get(0,1).r * .2;
      sumA += get(-1,1).r * .05;

      sumB += get(-1,0).g * .2;
      sumB += get(-1,-1).g * .05;
      sumB += get(0,-1).g * .2;
      sumB += get(1,-1).g * .05;
      sumB += get(1,0).g * .2;
      sumB += get(1,1).g * .05;
      sumB += get(0,1).g * .2;
      sumB += get(-1,1).g * .05;

      state.r = a + dA
        * sumA -
        a * b * b +
        f * (1. - a);

      state.g = b + dB *
        sumB +
        a * b * b -
        ((k+f) * b);

      return state;
    }
    void main() {
      vec2 nextState = run();
      gl_FragColor = vec4( nextState.r, nextState.g, 0., 1. );
    }
  </script>

  <script>
    window.onload = function() {
      let canvas = document.querySelector("canvas");
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      let gl = canvas.getContext("webgl");
      let stateSize = 2 ** Math.floor(Math.log(canvas.width) / Math.log(2));

      let verts = [1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1];

      let vertBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vertBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verts), gl.STATIC_DRAW);
      gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(0);

      // --- compile and link our shaders to use ---
      let shaderScript = document.getElementById("vshader");
      let shaderSource = shaderScript.text;
      const vertexShader = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(vertexShader, shaderSource);
      gl.compileShader(vertexShader);
      console.log(gl.getShaderInfoLog(vertexShader)); // create fragment shader to run our simulation

      shaderScript = document.getElementById("fshader_render");
      shaderSource = shaderScript.text;
      const fragmentShaderRender = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(fragmentShaderRender, shaderSource);
      gl.compileShader(fragmentShaderRender);
      console.log(gl.getShaderInfoLog(fragmentShaderRender)); // create shader program const

      programRender = gl.createProgram();
      gl.attachShader(programRender, vertexShader);
      gl.attachShader(programRender, fragmentShaderRender);
      gl.linkProgram(programRender);
      gl.useProgram(programRender);

      // create pointer to vertex array and uniform sharing simulation size
      const position = gl.getAttribLocation(programRender, "a_position");
      gl.enableVertexAttribArray(position);
      gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 0, 0);
      let scale = gl.getUniformLocation(programRender, "scale");
      gl.uniform2f(scale, stateSize, stateSize);

      // create shader program to draw our simulation to the screen
      shaderScript = document.getElementById("fshader_draw");
      shaderSource = shaderScript.text;
      fragmentShaderDraw = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(fragmentShaderDraw, shaderSource);
      gl.compileShader(fragmentShaderDraw);
      console.log(gl.getShaderInfoLog(fragmentShaderDraw));

      // create shader program
      programDraw = gl.createProgram();
      gl.attachShader(programDraw, vertexShader);
      gl.attachShader(programDraw, fragmentShaderDraw);
      gl.linkProgram(programDraw);
      gl.useProgram(programDraw);

      scale = gl.getUniformLocation(programDraw, "scale");
      gl.uniform2f(scale, canvas.width, canvas.height);
      const position2 = gl.getAttribLocation(programDraw, "a_position");
      gl.enableVertexAttribArray(position2);
      gl.vertexAttribPointer(position2, 2, gl.FLOAT, false, 0, 0);
    };
  </script>
</html>
